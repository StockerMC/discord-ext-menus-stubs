from typing import Callable, Coroutine, Any, TypeVar, Generic, Literal, Sequence, AsyncIterator, Final, overload
from discord.ext import commands
import discord
import functools

T = TypeVar('T')
T1 = TypeVar('T1')
_Coro = Coroutine[Any, Any, T]
_CoroFuncT = TypeVar('_CoroFuncT', bound=Callable[..., _Coro[Any]])

__version__: Final[str]

class MenuError(Exception):
    def __init__(self) -> None: ...

class CannotEmbedLinks(MenuError):
    def __init__(self) -> None: ...

class CannotSendMessages(MenuError):
    def __init__(self) -> None: ...

class CannotAddReactions(MenuError):
    def __init__(self) -> None: ...

class Position:
    number: int
    bucket: int
    def __init__(self, number: int, *, bucket: int = ...) -> None: ...
    def __lt__(self, other: Position) -> bool: ...
    def __eq__(self, other: Position) -> bool: ...
    def __le__(self, other: Position) -> bool: ...
    def __gt__(self, other: Position) -> bool: ...
    def __ge__(self, other: Position) -> bool: ...

class Last(Position):
    def __init__(self, number: int = ...) -> None: ...

class First(Position):
    def __init__(self, number: int = ...) -> None: ...

class Button(Generic[T]):
    emoji: discord.PartialEmoji
    position: Position
    lock: bool
    def __init__(
        self,
        emoji: discord.PartialEmoji | str,
        action: Callable[[Menu, discord.RawReactionActionEvent], _Coro[T]],
        skip_if: Callable[[Menu], bool] | None = ...,
        position: Position = ...,
        lock: bool = ...,
    ) -> None: ...
    @property
    def skip_if(self) -> Callable[[Menu], bool] | None: ...
    @skip_if.setter
    def skip_if(self, value: Callable[[Menu], bool] | None) -> None: ...
    @property
    def action(self) -> Callable[[Menu, discord.RawReactionActionEvent], _Coro[T]]: ...
    @action.setter
    def action(self, value: Callable[[Menu, discord.RawReactionActionEvent], _Coro[T]]) -> None: ...
    def __call__(self, menu: Menu, payload: discord.RawReactionActionEvent) -> _Coro[T]: ...
    def __str__(self) -> str: ...
    def is_valid(self, menu: Menu) -> bool: ...

def button(emoji: discord.PartialEmoji | str, **kwargs: Any) -> Callable[[_CoroFuncT], _CoroFuncT]: ...

class Menu:
    timeout: float
    delete_message_after: bool
    clear_reactions_after: bool
    check_embeds: bool
    ctx: commands.Context | None
    bot: commands.Bot | None
    message: discord.Message | None
    def __init__(
        self,
        *,
        timeout: float = ...,
        delete_message_after: bool = ...,
        clear_reactions_after: bool = ...,
        check_embeds: bool = ...,
        message: discord.Message | None = ...,
    ) -> None: ...
    # Technically this is discord.utils.cached_property
    @functools.cached_property
    def buttons(self) -> dict[discord.PartialEmoji, Button]: ...
    @overload
    def add_button(self, button: Button, *, react: Literal[True]) -> Callable[[], _Coro[None]]: ...
    @overload
    def add_button(self, button: Button, *, react: Literal[False] = ...) -> None: ...
    @overload
    def remove_button(self, emoji: Button | str, *, react: Literal[True]) -> Callable[[], _Coro[None]]: ...
    @overload
    def remove_button(self, emoji: Button | str, *, react: Literal[False] = ...) -> None: ...
    @overload
    def clear_buttons(self, *, react: Literal[True]) -> Callable[[], _Coro[None]]: ...
    @overload
    def clear_buttons(self, *, react: Literal[False] = ...) -> None: ...
    def should_add_reactions(self) -> int: ...
    def reaction_check(self, payload: discord.RawReactionActionEvent) -> bool: ...
    async def update(self, payload: discord.RawReactionActionEvent) -> None: ...
    async def on_menu_button_error(self, exc: Exception) -> None: ...
    async def start(
        self, ctx: commands.Context, *, channel: discord.abc.Messageable | None = ..., wait: bool = ...
    ) -> None: ...
    async def finalize(self, timed_out: bool) -> None: ...
    async def send_initial_message(
        self, ctx: commands.Context, channel: discord.abc.Messageable
    ) -> discord.Message: ...
    def stop(self) -> None: ...

class PageSource(Generic[T]):
    async def prepare(self) -> None: ...
    def is_paginating(self) -> bool: ...
    def get_max_pages(self) -> int | None: ...
    async def get_page(self, page_number: int) -> T: ...
    async def format_page(self, menu: Menu, page: T) -> str | discord.Embed | dict[str, Any]: ...

class MenuPages(Menu):
    current_page: int
    def __init__(self, source: PageSource, **kwargs: Any) -> None: ...
    @property
    def source(self) -> PageSource: ...
    async def change_source(self, source: PageSource) -> None: ...
    def should_add_reactions(self) -> bool: ...
    async def show_page(self, page_number: int) -> None: ...
    async def start(
        self, ctx: commands.Context, *, channel: discord.abc.Messageable = ..., wait: bool = ...
    ) -> None: ...
    async def show_checked_page(self, page_number: int) -> None: ...
    async def show_current_page(self) -> None: ...

class ListPageSource(PageSource[T]):
    entries: Sequence[T]
    per_page: int
    def __init__(self, entries: Sequence[T], *, per_page: int) -> None: ...
    def is_paginating(self) -> bool: ...
    def get_max_pages(self) -> int: ...
    def get_page(self, page_number: int) -> T: ...

# It actually is a NamedTuple, but NamedTuple doesn't support multiple inheritance
class _GroupByEntry(Generic[T, T1]):
    key: T
    items: list[T1]

class GroupByPageSource(ListPageSource, Generic[T, T1]):
    def __init__(
        self, entries: Sequence[T], *, key: Callable[[T], T1], per_page: int, sort: bool = ...
    ) -> None: ...
    async def get_page(self, page_number: int) -> T: ...
    async def format_page(self, menu: Menu, entry: _GroupByEntry[T1, T]) -> dict[str, Any]: ...

class AsyncIteratorPageSource(PageSource[T]):
    iter: AsyncIterator[T]
    per_page: int
    def __init__(self, iterator: AsyncIterator[Any], *, per_page: int) -> None: ...
    async def get_page(self, page_number: int) -> T | list[T]: ...
